import random
from pytreemap import TreeMap
from typing import List
from exploitability_sampling_Kuhn import *


# TODO: implement DudoNode instead of Node

class DudoTrainer:
    def __init__(self):  # Dudo definitions
        # Dudo definitions of 2 6-sided dice
        self.nodeMap = TreeMap()
        self.NUM_SIDES = 6
        self.NUM_ACTIONS = (2 * self.NUM_SIDES) + 1
        self.DUDO = self.NUM_ACTIONS - 1

        self.claimNum = ([1] * 6) + ([2] * 6)
        self.claimRank = [2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1]

    def rollDice(self) -> List[int]:
        return [random.randint(1, self.NUM_SIDES), random.randint(1, self.NUM_SIDES)]

    def infoSetToInt(self, playerRoll: int, isClaimed: List[bool]) -> int:  # convert Dudo information set to an integer
        infoSetNum = playerRoll
        for a in range(self.NUM_ACTIONS - 1).__reversed__():
            infoSetNum = 2 * infoSetNum + (1 if isClaimed[a] else 0)
        return infoSetNum

    def claimHistoryToString(self, isClaimed: List[bool]) -> str:  # convert Dudo claim history to a String
        sb = ""
        for a in range(self.NUM_ACTIONS):
            if isClaimed[a]:
                if len(sb) > 0:
                    sb += ','
                sb += str(self.claimNum[a])
                sb += '*'
                sb += str(self.claimRank[a])
        return sb

    # info set node class definitions (node class)
    # Counterfactual regret minimization iteration
    def cfr(self, dice: List[int], isClaimed: List[bool], p0: float, p1: float) -> float:  # history -> isClaimed
        plays = isClaimed.count(True)
        player = plays % 2
        # return payoff for terminal states
        if isClaimed[self.DUDO]:
            doubted = self.NUM_ACTIONS - 2 - isClaimed[self.NUM_ACTIONS - 2::-1].index(True)
            # print("doubted", doubted)
            cN = self.claimNum[doubted]
            cR = self.claimRank[doubted]
            realDoubtedRankQuantity = dice.count(cR) + dice.count(1) if cR != 1 else dice.count(cR)
            if realDoubtedRankQuantity >= cN:
                return 1  # Dudo loses -1,
            else:
                # вычесть
                return -1  # last stake player loses |actual - claimed|

        infoSet = str(self.infoSetToInt(dice[player], isClaimed))
        # <Get information set node or create it if nonexistent>
        node = self.nodeMap.get(infoSet)
        AfterTrueIndex = self.NUM_ACTIONS - isClaimed[self.NUM_ACTIONS - 1::-1].index(True) if True in isClaimed else 0
        if node is None:
            node = Node(self.NUM_ACTIONS - AfterTrueIndex if AfterTrueIndex > 0 else 12, isClaimed, dice[player])
            node.infoSet = infoSet
            # output feint with ears
            # node.die = dice[player]
            # node.isClaimed = isClaimed
            self.nodeMap.put(infoSet, node)

        # For each action, recursively call cfr with additional history and probability
        strategy = node.getStrategy(p0 if player == 0 else p1)
        util = [0.0] * self.NUM_ACTIONS
        nodeUtil = 0
        for i in range(node.NUM_ACTIONS):
            nextHistory = isClaimed.copy()
            iter = AfterTrueIndex + i
            nextHistory[iter] = True
            if player == 0:
                util[i] = -self.cfr(dice, nextHistory, p0 * strategy[i], p1)
            else:
                util[i] = -self.cfr(dice, nextHistory, p0, p1 * strategy[i])
            nodeUtil += strategy[i] * util[i]
        # For each action, compute and accumulate counterfactual regret
        for a in range(node.NUM_ACTIONS):
            regret = util[a] - nodeUtil
            node.regretSum[a] += (p1 if player == 0 else p0) * regret
        return nodeUtil

    def count_exploitability(self,
                             dice: List[int],
                             isClaimed: List[bool],
                             p0: float,
                             p1: float,
                             u_1: float) -> float:

        plays = isClaimed.count(True)
        player = plays % 2
        # return payoff for terminal states
        if isClaimed[self.DUDO]:
            doubted = self.NUM_ACTIONS - 2 - isClaimed[self.NUM_ACTIONS - 2::-1].index(True)
            # print("doubted", doubted)
            cN = self.claimNum[doubted]
            cR = self.claimRank[doubted]
            realDoubtedRankQuantity = dice.count(cR) + dice.count(1) if cR != 1 else dice.count(cR)
            if realDoubtedRankQuantity >= cN:
                return 1  # Dudo loses -1,
            else:
                # вычесть
                return -1  # last stake player loses |actual - claimed|
        infoSet = str(self.infoSetToInt(dice[player], isClaimed))
        node = self.nodeMap.get(infoSet)
        AfterTrueIndex = self.NUM_ACTIONS - isClaimed[self.NUM_ACTIONS - 1::-1].index(True) if True in isClaimed else 0
        # if node is None:
        #     node = Node(self.NUM_ACTIONS - AfterTrueIndex if AfterTrueIndex > 0 else 12, isClaimed, dice[player])
        #     node.infoSet = infoSet
        #     # output feint with ears
        #     # node.die = dice[player]
        #     # node.isClaimed = isClaimed
        #     self.nodeMap.put(infoSet, node)

        # For each action, recursively call cfr with additional history and probability
        strategy = node.getStrategy(p0 if player == 0 else p1)
        util = [0.0] * self.NUM_ACTIONS
        BR = 0
        for i in range(node.NUM_ACTIONS):
            nextHistory = isClaimed.copy()
            iter = AfterTrueIndex + i
            nextHistory[iter] = True
            if player == 0:
                # dice, [False] * self.NUM_ACTIONS, 1, 1, util / i
                util[i] = -self.count_exploitability(dice, nextHistory, p0 * strategy[i], p1, u_1)
                BR += strategy[i] * util[i]
            else:
                util[i] = -self.count_exploitability(dice, nextHistory, p0, p1 * strategy[i], u_1)
        if player == 1:
            # chose_flag = strategy[0] * util[0] > strategy[1] * util[1]
            st_util = []
            for i in range(node.NUM_ACTIONS):
                st_util.append(strategy[i] * util[i])
            BR += max(st_util)

        # For each action, compute and accumulate counterfactual regret
        # for a in range(node.NUM_ACTIONS):
        #     regret = util[a] - BR
        #     node.regretSum[a] += (p1 if player == 0 else p0) * regret
        # return nodeUtil

        return abs(BR - u_1)

    # Train Dudo
    def train(self, iterations: int):
        util = 0.0
        cur_expl = 0
        results = []
        for i in range(1, iterations + 1):

            dice = self.rollDice()
            startClaims = [False] * self.NUM_ACTIONS
            util += self.cfr(dice, startClaims, 1, 1)
            # TODO: call exploitability counting (only for the second player here)
            cur_expl = self.count_exploitability(dice, [False] * self.NUM_ACTIONS, 1, 1, util / i)
            if i % 100 == 0:
                print(i)
                results.append(cur_expl)
        utils.save_result_to_file(results, "expl_MCCFR")
        print("The number of iterations: ", iterations)
        print("Average game value: ", util / iterations)
        print(cur_expl)
        # for n in self.nodeMap.values():  # print cards + history
        #     print(n.die, self.claimHistoryToString(n.isClaimed), n.toString(), sep='|')
        #     print()
        return self

    def getNode(self, die: int, isClaimed: List[bool]) -> str:
        infoSet = str(self.infoSetToInt(die, isClaimed))
        if infoSet in self.nodeMap:
            return self.nodeMap.get(infoSet).toString()
        else:
            return Node(self.NUM_ACTIONS, [False] * 13).toString()  # change properly -1?


# DudoTrainer main method
if __name__ == '__main__':
    iterations = 4000
    TrainRes = DudoTrainer().train(iterations)

